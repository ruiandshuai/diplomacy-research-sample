// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: diplomacy_tensorflow/contrib/training/python/training/hparam.proto

#ifndef PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto
#define PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto 

namespace protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto
namespace diplomacy {
namespace tensorflow {
class HParamDef;
class HParamDefDefaultTypeInternal;
extern HParamDefDefaultTypeInternal _HParamDef_default_instance_;
class HParamDef_BoolList;
class HParamDef_BoolListDefaultTypeInternal;
extern HParamDef_BoolListDefaultTypeInternal _HParamDef_BoolList_default_instance_;
class HParamDef_BytesList;
class HParamDef_BytesListDefaultTypeInternal;
extern HParamDef_BytesListDefaultTypeInternal _HParamDef_BytesList_default_instance_;
class HParamDef_FloatList;
class HParamDef_FloatListDefaultTypeInternal;
extern HParamDef_FloatListDefaultTypeInternal _HParamDef_FloatList_default_instance_;
class HParamDef_HParamType;
class HParamDef_HParamTypeDefaultTypeInternal;
extern HParamDef_HParamTypeDefaultTypeInternal _HParamDef_HParamType_default_instance_;
class HParamDef_HparamEntry_DoNotUse;
class HParamDef_HparamEntry_DoNotUseDefaultTypeInternal;
extern HParamDef_HparamEntry_DoNotUseDefaultTypeInternal _HParamDef_HparamEntry_DoNotUse_default_instance_;
class HParamDef_Int64List;
class HParamDef_Int64ListDefaultTypeInternal;
extern HParamDef_Int64ListDefaultTypeInternal _HParamDef_Int64List_default_instance_;
}  // namespace tensorflow
}  // namespace diplomacy
namespace google {
namespace protobuf {
template<> ::diplomacy::tensorflow::HParamDef* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_BoolList* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_BoolList>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_BytesList* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_BytesList>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_FloatList* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_FloatList>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_HParamType* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_HParamType>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_HparamEntry_DoNotUse* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_HparamEntry_DoNotUse>(Arena*);
template<> ::diplomacy::tensorflow::HParamDef_Int64List* Arena::CreateMaybeMessage<::diplomacy::tensorflow::HParamDef_Int64List>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace diplomacy {
namespace tensorflow {

// ===================================================================

class HParamDef_BytesList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef.BytesList) */ {
 public:
  HParamDef_BytesList();
  virtual ~HParamDef_BytesList();

  HParamDef_BytesList(const HParamDef_BytesList& from);

  inline HParamDef_BytesList& operator=(const HParamDef_BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef_BytesList(HParamDef_BytesList&& from) noexcept
    : HParamDef_BytesList() {
    *this = ::std::move(from);
  }

  inline HParamDef_BytesList& operator=(HParamDef_BytesList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_BytesList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef_BytesList* internal_default_instance() {
    return reinterpret_cast<const HParamDef_BytesList*>(
               &_HParamDef_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(HParamDef_BytesList* other);
  void Swap(HParamDef_BytesList* other);
  friend void swap(HParamDef_BytesList& a, HParamDef_BytesList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef_BytesList* New() const final {
    return CreateMaybeMessage<HParamDef_BytesList>(NULL);
  }

  HParamDef_BytesList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef_BytesList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef_BytesList& from);
  void MergeFrom(const HParamDef_BytesList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef_BytesList* other);
  protected:
  explicit HParamDef_BytesList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef.BytesList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HParamDef_FloatList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef.FloatList) */ {
 public:
  HParamDef_FloatList();
  virtual ~HParamDef_FloatList();

  HParamDef_FloatList(const HParamDef_FloatList& from);

  inline HParamDef_FloatList& operator=(const HParamDef_FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef_FloatList(HParamDef_FloatList&& from) noexcept
    : HParamDef_FloatList() {
    *this = ::std::move(from);
  }

  inline HParamDef_FloatList& operator=(HParamDef_FloatList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_FloatList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef_FloatList* internal_default_instance() {
    return reinterpret_cast<const HParamDef_FloatList*>(
               &_HParamDef_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(HParamDef_FloatList* other);
  void Swap(HParamDef_FloatList* other);
  friend void swap(HParamDef_FloatList& a, HParamDef_FloatList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef_FloatList* New() const final {
    return CreateMaybeMessage<HParamDef_FloatList>(NULL);
  }

  HParamDef_FloatList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef_FloatList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef_FloatList& from);
  void MergeFrom(const HParamDef_FloatList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef_FloatList* other);
  protected:
  explicit HParamDef_FloatList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HParamDef_Int64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef.Int64List) */ {
 public:
  HParamDef_Int64List();
  virtual ~HParamDef_Int64List();

  HParamDef_Int64List(const HParamDef_Int64List& from);

  inline HParamDef_Int64List& operator=(const HParamDef_Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef_Int64List(HParamDef_Int64List&& from) noexcept
    : HParamDef_Int64List() {
    *this = ::std::move(from);
  }

  inline HParamDef_Int64List& operator=(HParamDef_Int64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_Int64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef_Int64List* internal_default_instance() {
    return reinterpret_cast<const HParamDef_Int64List*>(
               &_HParamDef_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(HParamDef_Int64List* other);
  void Swap(HParamDef_Int64List* other);
  friend void swap(HParamDef_Int64List& a, HParamDef_Int64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef_Int64List* New() const final {
    return CreateMaybeMessage<HParamDef_Int64List>(NULL);
  }

  HParamDef_Int64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef_Int64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef_Int64List& from);
  void MergeFrom(const HParamDef_Int64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef_Int64List* other);
  protected:
  explicit HParamDef_Int64List(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value(int index) const;
  void set_value(int index, ::google::protobuf::int64 value);
  void add_value(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef.Int64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HParamDef_BoolList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef.BoolList) */ {
 public:
  HParamDef_BoolList();
  virtual ~HParamDef_BoolList();

  HParamDef_BoolList(const HParamDef_BoolList& from);

  inline HParamDef_BoolList& operator=(const HParamDef_BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef_BoolList(HParamDef_BoolList&& from) noexcept
    : HParamDef_BoolList() {
    *this = ::std::move(from);
  }

  inline HParamDef_BoolList& operator=(HParamDef_BoolList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_BoolList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef_BoolList* internal_default_instance() {
    return reinterpret_cast<const HParamDef_BoolList*>(
               &_HParamDef_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(HParamDef_BoolList* other);
  void Swap(HParamDef_BoolList* other);
  friend void swap(HParamDef_BoolList& a, HParamDef_BoolList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef_BoolList* New() const final {
    return CreateMaybeMessage<HParamDef_BoolList>(NULL);
  }

  HParamDef_BoolList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef_BoolList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef_BoolList& from);
  void MergeFrom(const HParamDef_BoolList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef_BoolList* other);
  protected:
  explicit HParamDef_BoolList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  bool value(int index) const;
  void set_value(int index, bool value);
  void add_value(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      value() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef.BoolList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< bool > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HParamDef_HParamType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef.HParamType) */ {
 public:
  HParamDef_HParamType();
  virtual ~HParamDef_HParamType();

  HParamDef_HParamType(const HParamDef_HParamType& from);

  inline HParamDef_HParamType& operator=(const HParamDef_HParamType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef_HParamType(HParamDef_HParamType&& from) noexcept
    : HParamDef_HParamType() {
    *this = ::std::move(from);
  }

  inline HParamDef_HParamType& operator=(HParamDef_HParamType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef_HParamType& default_instance();

  enum KindCase {
    kInt64Value = 1,
    kFloatValue = 2,
    kBytesValue = 3,
    kBoolValue = 7,
    kInt64List = 4,
    kFloatList = 5,
    kBytesList = 6,
    kBoolList = 8,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef_HParamType* internal_default_instance() {
    return reinterpret_cast<const HParamDef_HParamType*>(
               &_HParamDef_HParamType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(HParamDef_HParamType* other);
  void Swap(HParamDef_HParamType* other);
  friend void swap(HParamDef_HParamType& a, HParamDef_HParamType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef_HParamType* New() const final {
    return CreateMaybeMessage<HParamDef_HParamType>(NULL);
  }

  HParamDef_HParamType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef_HParamType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef_HParamType& from);
  void MergeFrom(const HParamDef_HParamType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef_HParamType* other);
  protected:
  explicit HParamDef_HParamType(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 int64_value = 1;
  private:
  bool has_int64_value() const;
  public:
  void clear_int64_value();
  static const int kInt64ValueFieldNumber = 1;
  ::google::protobuf::int64 int64_value() const;
  void set_int64_value(::google::protobuf::int64 value);

  // float float_value = 2;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  float float_value() const;
  void set_float_value(float value);

  // bytes bytes_value = 3;
  private:
  bool has_bytes_value() const;
  public:
  void clear_bytes_value();
  static const int kBytesValueFieldNumber = 3;
  const ::std::string& bytes_value() const;
  void set_bytes_value(const ::std::string& value);
  #if LANG_CXX11
  void set_bytes_value(::std::string&& value);
  #endif
  void set_bytes_value(const char* value);
  void set_bytes_value(const void* value, size_t size);
  ::std::string* mutable_bytes_value();
  ::std::string* release_bytes_value();
  void set_allocated_bytes_value(::std::string* bytes_value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_bytes_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_bytes_value(
      ::std::string* bytes_value);

  // bool bool_value = 7;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 7;
  bool bool_value() const;
  void set_bool_value(bool value);

  // .diplomacy.tensorflow.HParamDef.Int64List int64_list = 4;
  bool has_int64_list() const;
  void clear_int64_list();
  static const int kInt64ListFieldNumber = 4;
  private:
  const ::diplomacy::tensorflow::HParamDef_Int64List& _internal_int64_list() const;
  public:
  const ::diplomacy::tensorflow::HParamDef_Int64List& int64_list() const;
  ::diplomacy::tensorflow::HParamDef_Int64List* release_int64_list();
  ::diplomacy::tensorflow::HParamDef_Int64List* mutable_int64_list();
  void set_allocated_int64_list(::diplomacy::tensorflow::HParamDef_Int64List* int64_list);
  void unsafe_arena_set_allocated_int64_list(
      ::diplomacy::tensorflow::HParamDef_Int64List* int64_list);
  ::diplomacy::tensorflow::HParamDef_Int64List* unsafe_arena_release_int64_list();

  // .diplomacy.tensorflow.HParamDef.FloatList float_list = 5;
  bool has_float_list() const;
  void clear_float_list();
  static const int kFloatListFieldNumber = 5;
  private:
  const ::diplomacy::tensorflow::HParamDef_FloatList& _internal_float_list() const;
  public:
  const ::diplomacy::tensorflow::HParamDef_FloatList& float_list() const;
  ::diplomacy::tensorflow::HParamDef_FloatList* release_float_list();
  ::diplomacy::tensorflow::HParamDef_FloatList* mutable_float_list();
  void set_allocated_float_list(::diplomacy::tensorflow::HParamDef_FloatList* float_list);
  void unsafe_arena_set_allocated_float_list(
      ::diplomacy::tensorflow::HParamDef_FloatList* float_list);
  ::diplomacy::tensorflow::HParamDef_FloatList* unsafe_arena_release_float_list();

  // .diplomacy.tensorflow.HParamDef.BytesList bytes_list = 6;
  bool has_bytes_list() const;
  void clear_bytes_list();
  static const int kBytesListFieldNumber = 6;
  private:
  const ::diplomacy::tensorflow::HParamDef_BytesList& _internal_bytes_list() const;
  public:
  const ::diplomacy::tensorflow::HParamDef_BytesList& bytes_list() const;
  ::diplomacy::tensorflow::HParamDef_BytesList* release_bytes_list();
  ::diplomacy::tensorflow::HParamDef_BytesList* mutable_bytes_list();
  void set_allocated_bytes_list(::diplomacy::tensorflow::HParamDef_BytesList* bytes_list);
  void unsafe_arena_set_allocated_bytes_list(
      ::diplomacy::tensorflow::HParamDef_BytesList* bytes_list);
  ::diplomacy::tensorflow::HParamDef_BytesList* unsafe_arena_release_bytes_list();

  // .diplomacy.tensorflow.HParamDef.BoolList bool_list = 8;
  bool has_bool_list() const;
  void clear_bool_list();
  static const int kBoolListFieldNumber = 8;
  private:
  const ::diplomacy::tensorflow::HParamDef_BoolList& _internal_bool_list() const;
  public:
  const ::diplomacy::tensorflow::HParamDef_BoolList& bool_list() const;
  ::diplomacy::tensorflow::HParamDef_BoolList* release_bool_list();
  ::diplomacy::tensorflow::HParamDef_BoolList* mutable_bool_list();
  void set_allocated_bool_list(::diplomacy::tensorflow::HParamDef_BoolList* bool_list);
  void unsafe_arena_set_allocated_bool_list(
      ::diplomacy::tensorflow::HParamDef_BoolList* bool_list);
  ::diplomacy::tensorflow::HParamDef_BoolList* unsafe_arena_release_bool_list();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef.HParamType)
 private:
  void set_has_int64_value();
  void set_has_float_value();
  void set_has_bytes_value();
  void set_has_bool_value();
  void set_has_int64_list();
  void set_has_float_list();
  void set_has_bytes_list();
  void set_has_bool_list();

  inline bool has_kind() const;
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    KindUnion() {}
    ::google::protobuf::int64 int64_value_;
    float float_value_;
    ::google::protobuf::internal::ArenaStringPtr bytes_value_;
    bool bool_value_;
    ::diplomacy::tensorflow::HParamDef_Int64List* int64_list_;
    ::diplomacy::tensorflow::HParamDef_FloatList* float_list_;
    ::diplomacy::tensorflow::HParamDef_BytesList* bytes_list_;
    ::diplomacy::tensorflow::HParamDef_BoolList* bool_list_;
  } kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HParamDef_HparamEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HParamDef_HparamEntry_DoNotUse, 
    ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<HParamDef_HparamEntry_DoNotUse, 
    ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  HParamDef_HparamEntry_DoNotUse();
  HParamDef_HparamEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HParamDef_HparamEntry_DoNotUse& other);
  static const HParamDef_HparamEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HParamDef_HparamEntry_DoNotUse*>(&_HParamDef_HparamEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HParamDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.HParamDef) */ {
 public:
  HParamDef();
  virtual ~HParamDef();

  HParamDef(const HParamDef& from);

  inline HParamDef& operator=(const HParamDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HParamDef(HParamDef&& from) noexcept
    : HParamDef() {
    *this = ::std::move(from);
  }

  inline HParamDef& operator=(HParamDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HParamDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HParamDef* internal_default_instance() {
    return reinterpret_cast<const HParamDef*>(
               &_HParamDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(HParamDef* other);
  void Swap(HParamDef* other);
  friend void swap(HParamDef& a, HParamDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HParamDef* New() const final {
    return CreateMaybeMessage<HParamDef>(NULL);
  }

  HParamDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HParamDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HParamDef& from);
  void MergeFrom(const HParamDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HParamDef* other);
  protected:
  explicit HParamDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HParamDef_BytesList BytesList;
  typedef HParamDef_FloatList FloatList;
  typedef HParamDef_Int64List Int64List;
  typedef HParamDef_BoolList BoolList;
  typedef HParamDef_HParamType HParamType;

  // accessors -------------------------------------------------------

  // map<string, .diplomacy.tensorflow.HParamDef.HParamType> hparam = 1;
  int hparam_size() const;
  void clear_hparam();
  static const int kHparamFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType >&
      hparam() const;
  ::google::protobuf::Map< ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType >*
      mutable_hparam();

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.HParamDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::MapField<
      HParamDef_HparamEntry_DoNotUse,
      ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > hparam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HParamDef_BytesList

// repeated bytes value = 1;
inline int HParamDef_BytesList::value_size() const {
  return value_.size();
}
inline void HParamDef_BytesList::clear_value() {
  value_.Clear();
}
inline const ::std::string& HParamDef_BytesList::value(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.BytesList.value)
  return value_.Get(index);
}
inline ::std::string* HParamDef_BytesList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.BytesList.value)
  return value_.Mutable(index);
}
inline void HParamDef_BytesList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.BytesList.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HParamDef_BytesList::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.BytesList.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HParamDef_BytesList::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.HParamDef.BytesList.value)
}
inline void HParamDef_BytesList::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.HParamDef.BytesList.value)
}
inline ::std::string* HParamDef_BytesList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:diplomacy.tensorflow.HParamDef.BytesList.value)
  return value_.Add();
}
inline void HParamDef_BytesList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.HParamDef.BytesList.value)
}
#if LANG_CXX11
inline void HParamDef_BytesList::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.HParamDef.BytesList.value)
}
#endif
inline void HParamDef_BytesList::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:diplomacy.tensorflow.HParamDef.BytesList.value)
}
inline void HParamDef_BytesList::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:diplomacy.tensorflow.HParamDef.BytesList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HParamDef_BytesList::value() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.HParamDef.BytesList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HParamDef_BytesList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.HParamDef.BytesList.value)
  return &value_;
}

// -------------------------------------------------------------------

// HParamDef_FloatList

// repeated float value = 1 [packed = true];
inline int HParamDef_FloatList::value_size() const {
  return value_.size();
}
inline void HParamDef_FloatList::clear_value() {
  value_.Clear();
}
inline float HParamDef_FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.FloatList.value)
  return value_.Get(index);
}
inline void HParamDef_FloatList::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.FloatList.value)
}
inline void HParamDef_FloatList::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.HParamDef.FloatList.value)
}
inline const ::google::protobuf::RepeatedField< float >&
HParamDef_FloatList::value() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.HParamDef.FloatList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
HParamDef_FloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.HParamDef.FloatList.value)
  return &value_;
}

// -------------------------------------------------------------------

// HParamDef_Int64List

// repeated int64 value = 1 [packed = true];
inline int HParamDef_Int64List::value_size() const {
  return value_.size();
}
inline void HParamDef_Int64List::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int64 HParamDef_Int64List::value(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.Int64List.value)
  return value_.Get(index);
}
inline void HParamDef_Int64List::set_value(int index, ::google::protobuf::int64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.Int64List.value)
}
inline void HParamDef_Int64List::add_value(::google::protobuf::int64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.HParamDef.Int64List.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
HParamDef_Int64List::value() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.HParamDef.Int64List.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
HParamDef_Int64List::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.HParamDef.Int64List.value)
  return &value_;
}

// -------------------------------------------------------------------

// HParamDef_BoolList

// repeated bool value = 1 [packed = true];
inline int HParamDef_BoolList::value_size() const {
  return value_.size();
}
inline void HParamDef_BoolList::clear_value() {
  value_.Clear();
}
inline bool HParamDef_BoolList::value(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.BoolList.value)
  return value_.Get(index);
}
inline void HParamDef_BoolList::set_value(int index, bool value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.BoolList.value)
}
inline void HParamDef_BoolList::add_value(bool value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.HParamDef.BoolList.value)
}
inline const ::google::protobuf::RepeatedField< bool >&
HParamDef_BoolList::value() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.HParamDef.BoolList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< bool >*
HParamDef_BoolList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.HParamDef.BoolList.value)
  return &value_;
}

// -------------------------------------------------------------------

// HParamDef_HParamType

// int64 int64_value = 1;
inline bool HParamDef_HParamType::has_int64_value() const {
  return kind_case() == kInt64Value;
}
inline void HParamDef_HParamType::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void HParamDef_HParamType::clear_int64_value() {
  if (has_int64_value()) {
    kind_.int64_value_ = GOOGLE_LONGLONG(0);
    clear_has_kind();
  }
}
inline ::google::protobuf::int64 HParamDef_HParamType::int64_value() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.int64_value)
  if (has_int64_value()) {
    return kind_.int64_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void HParamDef_HParamType::set_int64_value(::google::protobuf::int64 value) {
  if (!has_int64_value()) {
    clear_kind();
    set_has_int64_value();
  }
  kind_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.HParamType.int64_value)
}

// float float_value = 2;
inline bool HParamDef_HParamType::has_float_value() const {
  return kind_case() == kFloatValue;
}
inline void HParamDef_HParamType::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void HParamDef_HParamType::clear_float_value() {
  if (has_float_value()) {
    kind_.float_value_ = 0;
    clear_has_kind();
  }
}
inline float HParamDef_HParamType::float_value() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.float_value)
  if (has_float_value()) {
    return kind_.float_value_;
  }
  return 0;
}
inline void HParamDef_HParamType::set_float_value(float value) {
  if (!has_float_value()) {
    clear_kind();
    set_has_float_value();
  }
  kind_.float_value_ = value;
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.HParamType.float_value)
}

// bytes bytes_value = 3;
inline bool HParamDef_HParamType::has_bytes_value() const {
  return kind_case() == kBytesValue;
}
inline void HParamDef_HParamType::set_has_bytes_value() {
  _oneof_case_[0] = kBytesValue;
}
inline void HParamDef_HParamType::clear_bytes_value() {
  if (has_bytes_value()) {
    kind_.bytes_value_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_kind();
  }
}
inline const ::std::string& HParamDef_HParamType::bytes_value() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
  if (has_bytes_value()) {
    return kind_.bytes_value_.Get();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void HParamDef_HParamType::set_bytes_value(const ::std::string& value) {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
#if LANG_CXX11
inline void HParamDef_HParamType::set_bytes_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
#endif
inline void HParamDef_HParamType::set_bytes_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
inline void HParamDef_HParamType::set_bytes_value(const void* value,
                             size_t size) {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.bytes_value_.Set(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
inline ::std::string* HParamDef_HParamType::mutable_bytes_value() {
  if (!has_bytes_value()) {
    clear_kind();
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return kind_.bytes_value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
inline ::std::string* HParamDef_HParamType::release_bytes_value() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
  if (has_bytes_value()) {
    clear_has_kind();
    return kind_.bytes_value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::set_allocated_bytes_value(::std::string* bytes_value) {
  if (!has_bytes_value()) {
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (bytes_value != NULL) {
    set_has_bytes_value();
    kind_.bytes_value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}
inline ::std::string* HParamDef_HParamType::unsafe_arena_release_bytes_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_bytes_value()) {
    clear_has_kind();
    return kind_.bytes_value_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_bytes_value(::std::string* bytes_value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_bytes_value()) {
    kind_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (bytes_value) {
    set_has_bytes_value();
    kind_.bytes_value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.bytes_value)
}

// bool bool_value = 7;
inline bool HParamDef_HParamType::has_bool_value() const {
  return kind_case() == kBoolValue;
}
inline void HParamDef_HParamType::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void HParamDef_HParamType::clear_bool_value() {
  if (has_bool_value()) {
    kind_.bool_value_ = false;
    clear_has_kind();
  }
}
inline bool HParamDef_HParamType::bool_value() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.bool_value)
  if (has_bool_value()) {
    return kind_.bool_value_;
  }
  return false;
}
inline void HParamDef_HParamType::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_kind();
    set_has_bool_value();
  }
  kind_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.HParamDef.HParamType.bool_value)
}

// .diplomacy.tensorflow.HParamDef.Int64List int64_list = 4;
inline bool HParamDef_HParamType::has_int64_list() const {
  return kind_case() == kInt64List;
}
inline void HParamDef_HParamType::set_has_int64_list() {
  _oneof_case_[0] = kInt64List;
}
inline void HParamDef_HParamType::clear_int64_list() {
  if (has_int64_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.int64_list_;
    }
    clear_has_kind();
  }
}
inline const ::diplomacy::tensorflow::HParamDef_Int64List& HParamDef_HParamType::_internal_int64_list() const {
  return *kind_.int64_list_;
}
inline ::diplomacy::tensorflow::HParamDef_Int64List* HParamDef_HParamType::release_int64_list() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.HParamDef.HParamType.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
      ::diplomacy::tensorflow::HParamDef_Int64List* temp = kind_.int64_list_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    kind_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::diplomacy::tensorflow::HParamDef_Int64List& HParamDef_HParamType::int64_list() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.int64_list)
  return has_int64_list()
      ? *kind_.int64_list_
      : *reinterpret_cast< ::diplomacy::tensorflow::HParamDef_Int64List*>(&::diplomacy::tensorflow::_HParamDef_Int64List_default_instance_);
}
inline ::diplomacy::tensorflow::HParamDef_Int64List* HParamDef_HParamType::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:diplomacy.tensorflow.HParamDef.HParamType.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    ::diplomacy::tensorflow::HParamDef_Int64List* temp = kind_.int64_list_;
    kind_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_int64_list(::diplomacy::tensorflow::HParamDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.int64_list)
}
inline ::diplomacy::tensorflow::HParamDef_Int64List* HParamDef_HParamType::mutable_int64_list() {
  if (!has_int64_list()) {
    clear_kind();
    set_has_int64_list();
    kind_.int64_list_ = CreateMaybeMessage< ::diplomacy::tensorflow::HParamDef_Int64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.HParamType.int64_list)
  return kind_.int64_list_;
}

// .diplomacy.tensorflow.HParamDef.FloatList float_list = 5;
inline bool HParamDef_HParamType::has_float_list() const {
  return kind_case() == kFloatList;
}
inline void HParamDef_HParamType::set_has_float_list() {
  _oneof_case_[0] = kFloatList;
}
inline void HParamDef_HParamType::clear_float_list() {
  if (has_float_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.float_list_;
    }
    clear_has_kind();
  }
}
inline const ::diplomacy::tensorflow::HParamDef_FloatList& HParamDef_HParamType::_internal_float_list() const {
  return *kind_.float_list_;
}
inline ::diplomacy::tensorflow::HParamDef_FloatList* HParamDef_HParamType::release_float_list() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.HParamDef.HParamType.float_list)
  if (has_float_list()) {
    clear_has_kind();
      ::diplomacy::tensorflow::HParamDef_FloatList* temp = kind_.float_list_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    kind_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::diplomacy::tensorflow::HParamDef_FloatList& HParamDef_HParamType::float_list() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.float_list)
  return has_float_list()
      ? *kind_.float_list_
      : *reinterpret_cast< ::diplomacy::tensorflow::HParamDef_FloatList*>(&::diplomacy::tensorflow::_HParamDef_FloatList_default_instance_);
}
inline ::diplomacy::tensorflow::HParamDef_FloatList* HParamDef_HParamType::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:diplomacy.tensorflow.HParamDef.HParamType.float_list)
  if (has_float_list()) {
    clear_has_kind();
    ::diplomacy::tensorflow::HParamDef_FloatList* temp = kind_.float_list_;
    kind_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_float_list(::diplomacy::tensorflow::HParamDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.float_list)
}
inline ::diplomacy::tensorflow::HParamDef_FloatList* HParamDef_HParamType::mutable_float_list() {
  if (!has_float_list()) {
    clear_kind();
    set_has_float_list();
    kind_.float_list_ = CreateMaybeMessage< ::diplomacy::tensorflow::HParamDef_FloatList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.HParamType.float_list)
  return kind_.float_list_;
}

// .diplomacy.tensorflow.HParamDef.BytesList bytes_list = 6;
inline bool HParamDef_HParamType::has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline void HParamDef_HParamType::set_has_bytes_list() {
  _oneof_case_[0] = kBytesList;
}
inline void HParamDef_HParamType::clear_bytes_list() {
  if (has_bytes_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.bytes_list_;
    }
    clear_has_kind();
  }
}
inline const ::diplomacy::tensorflow::HParamDef_BytesList& HParamDef_HParamType::_internal_bytes_list() const {
  return *kind_.bytes_list_;
}
inline ::diplomacy::tensorflow::HParamDef_BytesList* HParamDef_HParamType::release_bytes_list() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.HParamDef.HParamType.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
      ::diplomacy::tensorflow::HParamDef_BytesList* temp = kind_.bytes_list_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    kind_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::diplomacy::tensorflow::HParamDef_BytesList& HParamDef_HParamType::bytes_list() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.bytes_list)
  return has_bytes_list()
      ? *kind_.bytes_list_
      : *reinterpret_cast< ::diplomacy::tensorflow::HParamDef_BytesList*>(&::diplomacy::tensorflow::_HParamDef_BytesList_default_instance_);
}
inline ::diplomacy::tensorflow::HParamDef_BytesList* HParamDef_HParamType::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:diplomacy.tensorflow.HParamDef.HParamType.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    ::diplomacy::tensorflow::HParamDef_BytesList* temp = kind_.bytes_list_;
    kind_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_bytes_list(::diplomacy::tensorflow::HParamDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.bytes_list)
}
inline ::diplomacy::tensorflow::HParamDef_BytesList* HParamDef_HParamType::mutable_bytes_list() {
  if (!has_bytes_list()) {
    clear_kind();
    set_has_bytes_list();
    kind_.bytes_list_ = CreateMaybeMessage< ::diplomacy::tensorflow::HParamDef_BytesList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.HParamType.bytes_list)
  return kind_.bytes_list_;
}

// .diplomacy.tensorflow.HParamDef.BoolList bool_list = 8;
inline bool HParamDef_HParamType::has_bool_list() const {
  return kind_case() == kBoolList;
}
inline void HParamDef_HParamType::set_has_bool_list() {
  _oneof_case_[0] = kBoolList;
}
inline void HParamDef_HParamType::clear_bool_list() {
  if (has_bool_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.bool_list_;
    }
    clear_has_kind();
  }
}
inline const ::diplomacy::tensorflow::HParamDef_BoolList& HParamDef_HParamType::_internal_bool_list() const {
  return *kind_.bool_list_;
}
inline ::diplomacy::tensorflow::HParamDef_BoolList* HParamDef_HParamType::release_bool_list() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.HParamDef.HParamType.bool_list)
  if (has_bool_list()) {
    clear_has_kind();
      ::diplomacy::tensorflow::HParamDef_BoolList* temp = kind_.bool_list_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    kind_.bool_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::diplomacy::tensorflow::HParamDef_BoolList& HParamDef_HParamType::bool_list() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.HParamDef.HParamType.bool_list)
  return has_bool_list()
      ? *kind_.bool_list_
      : *reinterpret_cast< ::diplomacy::tensorflow::HParamDef_BoolList*>(&::diplomacy::tensorflow::_HParamDef_BoolList_default_instance_);
}
inline ::diplomacy::tensorflow::HParamDef_BoolList* HParamDef_HParamType::unsafe_arena_release_bool_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:diplomacy.tensorflow.HParamDef.HParamType.bool_list)
  if (has_bool_list()) {
    clear_has_kind();
    ::diplomacy::tensorflow::HParamDef_BoolList* temp = kind_.bool_list_;
    kind_.bool_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HParamDef_HParamType::unsafe_arena_set_allocated_bool_list(::diplomacy::tensorflow::HParamDef_BoolList* bool_list) {
  clear_kind();
  if (bool_list) {
    set_has_bool_list();
    kind_.bool_list_ = bool_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:diplomacy.tensorflow.HParamDef.HParamType.bool_list)
}
inline ::diplomacy::tensorflow::HParamDef_BoolList* HParamDef_HParamType::mutable_bool_list() {
  if (!has_bool_list()) {
    clear_kind();
    set_has_bool_list();
    kind_.bool_list_ = CreateMaybeMessage< ::diplomacy::tensorflow::HParamDef_BoolList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.HParamDef.HParamType.bool_list)
  return kind_.bool_list_;
}

inline bool HParamDef_HParamType::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void HParamDef_HParamType::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline HParamDef_HParamType::KindCase HParamDef_HParamType::kind_case() const {
  return HParamDef_HParamType::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HParamDef

// map<string, .diplomacy.tensorflow.HParamDef.HParamType> hparam = 1;
inline int HParamDef::hparam_size() const {
  return hparam_.size();
}
inline void HParamDef::clear_hparam() {
  hparam_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType >&
HParamDef::hparam() const {
  // @@protoc_insertion_point(field_map:diplomacy.tensorflow.HParamDef.hparam)
  return hparam_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::diplomacy::tensorflow::HParamDef_HParamType >*
HParamDef::mutable_hparam() {
  // @@protoc_insertion_point(field_mutable_map:diplomacy.tensorflow.HParamDef.hparam)
  return hparam_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow
}  // namespace diplomacy

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftraining_2fpython_2ftraining_2fhparam_2eproto
