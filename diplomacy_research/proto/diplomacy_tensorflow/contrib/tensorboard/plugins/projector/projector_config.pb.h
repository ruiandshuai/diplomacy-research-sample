// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: diplomacy_tensorflow/contrib/tensorboard/plugins/projector/projector_config.proto

#ifndef PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto
#define PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto 

namespace protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto
namespace diplomacy {
namespace tensorflow {
class EmbeddingInfo;
class EmbeddingInfoDefaultTypeInternal;
extern EmbeddingInfoDefaultTypeInternal _EmbeddingInfo_default_instance_;
class ProjectorConfig;
class ProjectorConfigDefaultTypeInternal;
extern ProjectorConfigDefaultTypeInternal _ProjectorConfig_default_instance_;
class SpriteMetadata;
class SpriteMetadataDefaultTypeInternal;
extern SpriteMetadataDefaultTypeInternal _SpriteMetadata_default_instance_;
}  // namespace tensorflow
}  // namespace diplomacy
namespace google {
namespace protobuf {
template<> ::diplomacy::tensorflow::EmbeddingInfo* Arena::CreateMaybeMessage<::diplomacy::tensorflow::EmbeddingInfo>(Arena*);
template<> ::diplomacy::tensorflow::ProjectorConfig* Arena::CreateMaybeMessage<::diplomacy::tensorflow::ProjectorConfig>(Arena*);
template<> ::diplomacy::tensorflow::SpriteMetadata* Arena::CreateMaybeMessage<::diplomacy::tensorflow::SpriteMetadata>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace diplomacy {
namespace tensorflow {

// ===================================================================

class SpriteMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.SpriteMetadata) */ {
 public:
  SpriteMetadata();
  virtual ~SpriteMetadata();

  SpriteMetadata(const SpriteMetadata& from);

  inline SpriteMetadata& operator=(const SpriteMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpriteMetadata(SpriteMetadata&& from) noexcept
    : SpriteMetadata() {
    *this = ::std::move(from);
  }

  inline SpriteMetadata& operator=(SpriteMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpriteMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpriteMetadata* internal_default_instance() {
    return reinterpret_cast<const SpriteMetadata*>(
               &_SpriteMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SpriteMetadata* other);
  friend void swap(SpriteMetadata& a, SpriteMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpriteMetadata* New() const final {
    return CreateMaybeMessage<SpriteMetadata>(NULL);
  }

  SpriteMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpriteMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpriteMetadata& from);
  void MergeFrom(const SpriteMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpriteMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 single_image_dim = 2;
  int single_image_dim_size() const;
  void clear_single_image_dim();
  static const int kSingleImageDimFieldNumber = 2;
  ::google::protobuf::uint32 single_image_dim(int index) const;
  void set_single_image_dim(int index, ::google::protobuf::uint32 value);
  void add_single_image_dim(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      single_image_dim() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_single_image_dim();

  // string image_path = 1;
  void clear_image_path();
  static const int kImagePathFieldNumber = 1;
  const ::std::string& image_path() const;
  void set_image_path(const ::std::string& value);
  #if LANG_CXX11
  void set_image_path(::std::string&& value);
  #endif
  void set_image_path(const char* value);
  void set_image_path(const char* value, size_t size);
  ::std::string* mutable_image_path();
  ::std::string* release_image_path();
  void set_allocated_image_path(::std::string* image_path);

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.SpriteMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > single_image_dim_;
  mutable int _single_image_dim_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr image_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmbeddingInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.EmbeddingInfo) */ {
 public:
  EmbeddingInfo();
  virtual ~EmbeddingInfo();

  EmbeddingInfo(const EmbeddingInfo& from);

  inline EmbeddingInfo& operator=(const EmbeddingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmbeddingInfo(EmbeddingInfo&& from) noexcept
    : EmbeddingInfo() {
    *this = ::std::move(from);
  }

  inline EmbeddingInfo& operator=(EmbeddingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmbeddingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmbeddingInfo* internal_default_instance() {
    return reinterpret_cast<const EmbeddingInfo*>(
               &_EmbeddingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EmbeddingInfo* other);
  friend void swap(EmbeddingInfo& a, EmbeddingInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmbeddingInfo* New() const final {
    return CreateMaybeMessage<EmbeddingInfo>(NULL);
  }

  EmbeddingInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EmbeddingInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EmbeddingInfo& from);
  void MergeFrom(const EmbeddingInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmbeddingInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 tensor_shape = 4;
  int tensor_shape_size() const;
  void clear_tensor_shape();
  static const int kTensorShapeFieldNumber = 4;
  ::google::protobuf::uint32 tensor_shape(int index) const;
  void set_tensor_shape(int index, ::google::protobuf::uint32 value);
  void add_tensor_shape(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tensor_shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tensor_shape();

  // string tensor_name = 1;
  void clear_tensor_name();
  static const int kTensorNameFieldNumber = 1;
  const ::std::string& tensor_name() const;
  void set_tensor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tensor_name(::std::string&& value);
  #endif
  void set_tensor_name(const char* value);
  void set_tensor_name(const char* value, size_t size);
  ::std::string* mutable_tensor_name();
  ::std::string* release_tensor_name();
  void set_allocated_tensor_name(::std::string* tensor_name);

  // string metadata_path = 2;
  void clear_metadata_path();
  static const int kMetadataPathFieldNumber = 2;
  const ::std::string& metadata_path() const;
  void set_metadata_path(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata_path(::std::string&& value);
  #endif
  void set_metadata_path(const char* value);
  void set_metadata_path(const char* value, size_t size);
  ::std::string* mutable_metadata_path();
  ::std::string* release_metadata_path();
  void set_allocated_metadata_path(::std::string* metadata_path);

  // string bookmarks_path = 3;
  void clear_bookmarks_path();
  static const int kBookmarksPathFieldNumber = 3;
  const ::std::string& bookmarks_path() const;
  void set_bookmarks_path(const ::std::string& value);
  #if LANG_CXX11
  void set_bookmarks_path(::std::string&& value);
  #endif
  void set_bookmarks_path(const char* value);
  void set_bookmarks_path(const char* value, size_t size);
  ::std::string* mutable_bookmarks_path();
  ::std::string* release_bookmarks_path();
  void set_allocated_bookmarks_path(::std::string* bookmarks_path);

  // string tensor_path = 6;
  void clear_tensor_path();
  static const int kTensorPathFieldNumber = 6;
  const ::std::string& tensor_path() const;
  void set_tensor_path(const ::std::string& value);
  #if LANG_CXX11
  void set_tensor_path(::std::string&& value);
  #endif
  void set_tensor_path(const char* value);
  void set_tensor_path(const char* value, size_t size);
  ::std::string* mutable_tensor_path();
  ::std::string* release_tensor_path();
  void set_allocated_tensor_path(::std::string* tensor_path);

  // .diplomacy.tensorflow.SpriteMetadata sprite = 5;
  bool has_sprite() const;
  void clear_sprite();
  static const int kSpriteFieldNumber = 5;
  private:
  const ::diplomacy::tensorflow::SpriteMetadata& _internal_sprite() const;
  public:
  const ::diplomacy::tensorflow::SpriteMetadata& sprite() const;
  ::diplomacy::tensorflow::SpriteMetadata* release_sprite();
  ::diplomacy::tensorflow::SpriteMetadata* mutable_sprite();
  void set_allocated_sprite(::diplomacy::tensorflow::SpriteMetadata* sprite);

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.EmbeddingInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tensor_shape_;
  mutable int _tensor_shape_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr tensor_name_;
  ::google::protobuf::internal::ArenaStringPtr metadata_path_;
  ::google::protobuf::internal::ArenaStringPtr bookmarks_path_;
  ::google::protobuf::internal::ArenaStringPtr tensor_path_;
  ::diplomacy::tensorflow::SpriteMetadata* sprite_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProjectorConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:diplomacy.tensorflow.ProjectorConfig) */ {
 public:
  ProjectorConfig();
  virtual ~ProjectorConfig();

  ProjectorConfig(const ProjectorConfig& from);

  inline ProjectorConfig& operator=(const ProjectorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProjectorConfig(ProjectorConfig&& from) noexcept
    : ProjectorConfig() {
    *this = ::std::move(from);
  }

  inline ProjectorConfig& operator=(ProjectorConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectorConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectorConfig* internal_default_instance() {
    return reinterpret_cast<const ProjectorConfig*>(
               &_ProjectorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProjectorConfig* other);
  friend void swap(ProjectorConfig& a, ProjectorConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProjectorConfig* New() const final {
    return CreateMaybeMessage<ProjectorConfig>(NULL);
  }

  ProjectorConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProjectorConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProjectorConfig& from);
  void MergeFrom(const ProjectorConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectorConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .diplomacy.tensorflow.EmbeddingInfo embeddings = 2;
  int embeddings_size() const;
  void clear_embeddings();
  static const int kEmbeddingsFieldNumber = 2;
  ::diplomacy::tensorflow::EmbeddingInfo* mutable_embeddings(int index);
  ::google::protobuf::RepeatedPtrField< ::diplomacy::tensorflow::EmbeddingInfo >*
      mutable_embeddings();
  const ::diplomacy::tensorflow::EmbeddingInfo& embeddings(int index) const;
  ::diplomacy::tensorflow::EmbeddingInfo* add_embeddings();
  const ::google::protobuf::RepeatedPtrField< ::diplomacy::tensorflow::EmbeddingInfo >&
      embeddings() const;

  // string model_checkpoint_path = 1;
  void clear_model_checkpoint_path();
  static const int kModelCheckpointPathFieldNumber = 1;
  const ::std::string& model_checkpoint_path() const;
  void set_model_checkpoint_path(const ::std::string& value);
  #if LANG_CXX11
  void set_model_checkpoint_path(::std::string&& value);
  #endif
  void set_model_checkpoint_path(const char* value);
  void set_model_checkpoint_path(const char* value, size_t size);
  ::std::string* mutable_model_checkpoint_path();
  ::std::string* release_model_checkpoint_path();
  void set_allocated_model_checkpoint_path(::std::string* model_checkpoint_path);

  // string model_checkpoint_dir = 3;
  void clear_model_checkpoint_dir();
  static const int kModelCheckpointDirFieldNumber = 3;
  const ::std::string& model_checkpoint_dir() const;
  void set_model_checkpoint_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_model_checkpoint_dir(::std::string&& value);
  #endif
  void set_model_checkpoint_dir(const char* value);
  void set_model_checkpoint_dir(const char* value, size_t size);
  ::std::string* mutable_model_checkpoint_dir();
  ::std::string* release_model_checkpoint_dir();
  void set_allocated_model_checkpoint_dir(::std::string* model_checkpoint_dir);

  // @@protoc_insertion_point(class_scope:diplomacy.tensorflow.ProjectorConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::diplomacy::tensorflow::EmbeddingInfo > embeddings_;
  ::google::protobuf::internal::ArenaStringPtr model_checkpoint_path_;
  ::google::protobuf::internal::ArenaStringPtr model_checkpoint_dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpriteMetadata

// string image_path = 1;
inline void SpriteMetadata::clear_image_path() {
  image_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpriteMetadata::image_path() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.SpriteMetadata.image_path)
  return image_path_.GetNoArena();
}
inline void SpriteMetadata::set_image_path(const ::std::string& value) {
  
  image_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.SpriteMetadata.image_path)
}
#if LANG_CXX11
inline void SpriteMetadata::set_image_path(::std::string&& value) {
  
  image_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.SpriteMetadata.image_path)
}
#endif
inline void SpriteMetadata::set_image_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.SpriteMetadata.image_path)
}
inline void SpriteMetadata::set_image_path(const char* value, size_t size) {
  
  image_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.SpriteMetadata.image_path)
}
inline ::std::string* SpriteMetadata::mutable_image_path() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.SpriteMetadata.image_path)
  return image_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpriteMetadata::release_image_path() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.SpriteMetadata.image_path)
  
  return image_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpriteMetadata::set_allocated_image_path(::std::string* image_path) {
  if (image_path != NULL) {
    
  } else {
    
  }
  image_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_path);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.SpriteMetadata.image_path)
}

// repeated uint32 single_image_dim = 2;
inline int SpriteMetadata::single_image_dim_size() const {
  return single_image_dim_.size();
}
inline void SpriteMetadata::clear_single_image_dim() {
  single_image_dim_.Clear();
}
inline ::google::protobuf::uint32 SpriteMetadata::single_image_dim(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.SpriteMetadata.single_image_dim)
  return single_image_dim_.Get(index);
}
inline void SpriteMetadata::set_single_image_dim(int index, ::google::protobuf::uint32 value) {
  single_image_dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.SpriteMetadata.single_image_dim)
}
inline void SpriteMetadata::add_single_image_dim(::google::protobuf::uint32 value) {
  single_image_dim_.Add(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.SpriteMetadata.single_image_dim)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SpriteMetadata::single_image_dim() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.SpriteMetadata.single_image_dim)
  return single_image_dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SpriteMetadata::mutable_single_image_dim() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.SpriteMetadata.single_image_dim)
  return &single_image_dim_;
}

// -------------------------------------------------------------------

// EmbeddingInfo

// string tensor_name = 1;
inline void EmbeddingInfo::clear_tensor_name() {
  tensor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmbeddingInfo::tensor_name() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
  return tensor_name_.GetNoArena();
}
inline void EmbeddingInfo::set_tensor_name(const ::std::string& value) {
  
  tensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
}
#if LANG_CXX11
inline void EmbeddingInfo::set_tensor_name(::std::string&& value) {
  
  tensor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
}
#endif
inline void EmbeddingInfo::set_tensor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
}
inline void EmbeddingInfo::set_tensor_name(const char* value, size_t size) {
  
  tensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
}
inline ::std::string* EmbeddingInfo::mutable_tensor_name() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
  return tensor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmbeddingInfo::release_tensor_name() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
  
  return tensor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmbeddingInfo::set_allocated_tensor_name(::std::string* tensor_name) {
  if (tensor_name != NULL) {
    
  } else {
    
  }
  tensor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_name);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.EmbeddingInfo.tensor_name)
}

// string metadata_path = 2;
inline void EmbeddingInfo::clear_metadata_path() {
  metadata_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmbeddingInfo::metadata_path() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
  return metadata_path_.GetNoArena();
}
inline void EmbeddingInfo::set_metadata_path(const ::std::string& value) {
  
  metadata_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
}
#if LANG_CXX11
inline void EmbeddingInfo::set_metadata_path(::std::string&& value) {
  
  metadata_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
}
#endif
inline void EmbeddingInfo::set_metadata_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
}
inline void EmbeddingInfo::set_metadata_path(const char* value, size_t size) {
  
  metadata_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
}
inline ::std::string* EmbeddingInfo::mutable_metadata_path() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
  return metadata_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmbeddingInfo::release_metadata_path() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
  
  return metadata_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmbeddingInfo::set_allocated_metadata_path(::std::string* metadata_path) {
  if (metadata_path != NULL) {
    
  } else {
    
  }
  metadata_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata_path);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.EmbeddingInfo.metadata_path)
}

// string bookmarks_path = 3;
inline void EmbeddingInfo::clear_bookmarks_path() {
  bookmarks_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmbeddingInfo::bookmarks_path() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
  return bookmarks_path_.GetNoArena();
}
inline void EmbeddingInfo::set_bookmarks_path(const ::std::string& value) {
  
  bookmarks_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
}
#if LANG_CXX11
inline void EmbeddingInfo::set_bookmarks_path(::std::string&& value) {
  
  bookmarks_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
}
#endif
inline void EmbeddingInfo::set_bookmarks_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bookmarks_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
}
inline void EmbeddingInfo::set_bookmarks_path(const char* value, size_t size) {
  
  bookmarks_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
}
inline ::std::string* EmbeddingInfo::mutable_bookmarks_path() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
  return bookmarks_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmbeddingInfo::release_bookmarks_path() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
  
  return bookmarks_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmbeddingInfo::set_allocated_bookmarks_path(::std::string* bookmarks_path) {
  if (bookmarks_path != NULL) {
    
  } else {
    
  }
  bookmarks_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bookmarks_path);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.EmbeddingInfo.bookmarks_path)
}

// repeated uint32 tensor_shape = 4;
inline int EmbeddingInfo::tensor_shape_size() const {
  return tensor_shape_.size();
}
inline void EmbeddingInfo::clear_tensor_shape() {
  tensor_shape_.Clear();
}
inline ::google::protobuf::uint32 EmbeddingInfo::tensor_shape(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.tensor_shape)
  return tensor_shape_.Get(index);
}
inline void EmbeddingInfo::set_tensor_shape(int index, ::google::protobuf::uint32 value) {
  tensor_shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.EmbeddingInfo.tensor_shape)
}
inline void EmbeddingInfo::add_tensor_shape(::google::protobuf::uint32 value) {
  tensor_shape_.Add(value);
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.EmbeddingInfo.tensor_shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EmbeddingInfo::tensor_shape() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.EmbeddingInfo.tensor_shape)
  return tensor_shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EmbeddingInfo::mutable_tensor_shape() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.EmbeddingInfo.tensor_shape)
  return &tensor_shape_;
}

// .diplomacy.tensorflow.SpriteMetadata sprite = 5;
inline bool EmbeddingInfo::has_sprite() const {
  return this != internal_default_instance() && sprite_ != NULL;
}
inline void EmbeddingInfo::clear_sprite() {
  if (GetArenaNoVirtual() == NULL && sprite_ != NULL) {
    delete sprite_;
  }
  sprite_ = NULL;
}
inline const ::diplomacy::tensorflow::SpriteMetadata& EmbeddingInfo::_internal_sprite() const {
  return *sprite_;
}
inline const ::diplomacy::tensorflow::SpriteMetadata& EmbeddingInfo::sprite() const {
  const ::diplomacy::tensorflow::SpriteMetadata* p = sprite_;
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.sprite)
  return p != NULL ? *p : *reinterpret_cast<const ::diplomacy::tensorflow::SpriteMetadata*>(
      &::diplomacy::tensorflow::_SpriteMetadata_default_instance_);
}
inline ::diplomacy::tensorflow::SpriteMetadata* EmbeddingInfo::release_sprite() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.EmbeddingInfo.sprite)
  
  ::diplomacy::tensorflow::SpriteMetadata* temp = sprite_;
  sprite_ = NULL;
  return temp;
}
inline ::diplomacy::tensorflow::SpriteMetadata* EmbeddingInfo::mutable_sprite() {
  
  if (sprite_ == NULL) {
    auto* p = CreateMaybeMessage<::diplomacy::tensorflow::SpriteMetadata>(GetArenaNoVirtual());
    sprite_ = p;
  }
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.EmbeddingInfo.sprite)
  return sprite_;
}
inline void EmbeddingInfo::set_allocated_sprite(::diplomacy::tensorflow::SpriteMetadata* sprite) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sprite_;
  }
  if (sprite) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sprite = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sprite, submessage_arena);
    }
    
  } else {
    
  }
  sprite_ = sprite;
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.EmbeddingInfo.sprite)
}

// string tensor_path = 6;
inline void EmbeddingInfo::clear_tensor_path() {
  tensor_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EmbeddingInfo::tensor_path() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
  return tensor_path_.GetNoArena();
}
inline void EmbeddingInfo::set_tensor_path(const ::std::string& value) {
  
  tensor_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
}
#if LANG_CXX11
inline void EmbeddingInfo::set_tensor_path(::std::string&& value) {
  
  tensor_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
}
#endif
inline void EmbeddingInfo::set_tensor_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensor_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
}
inline void EmbeddingInfo::set_tensor_path(const char* value, size_t size) {
  
  tensor_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
}
inline ::std::string* EmbeddingInfo::mutable_tensor_path() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
  return tensor_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmbeddingInfo::release_tensor_path() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
  
  return tensor_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmbeddingInfo::set_allocated_tensor_path(::std::string* tensor_path) {
  if (tensor_path != NULL) {
    
  } else {
    
  }
  tensor_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_path);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.EmbeddingInfo.tensor_path)
}

// -------------------------------------------------------------------

// ProjectorConfig

// string model_checkpoint_path = 1;
inline void ProjectorConfig::clear_model_checkpoint_path() {
  model_checkpoint_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectorConfig::model_checkpoint_path() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
  return model_checkpoint_path_.GetNoArena();
}
inline void ProjectorConfig::set_model_checkpoint_path(const ::std::string& value) {
  
  model_checkpoint_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
}
#if LANG_CXX11
inline void ProjectorConfig::set_model_checkpoint_path(::std::string&& value) {
  
  model_checkpoint_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
}
#endif
inline void ProjectorConfig::set_model_checkpoint_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_checkpoint_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
}
inline void ProjectorConfig::set_model_checkpoint_path(const char* value, size_t size) {
  
  model_checkpoint_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
}
inline ::std::string* ProjectorConfig::mutable_model_checkpoint_path() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
  return model_checkpoint_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectorConfig::release_model_checkpoint_path() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
  
  return model_checkpoint_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectorConfig::set_allocated_model_checkpoint_path(::std::string* model_checkpoint_path) {
  if (model_checkpoint_path != NULL) {
    
  } else {
    
  }
  model_checkpoint_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_checkpoint_path);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_path)
}

// repeated .diplomacy.tensorflow.EmbeddingInfo embeddings = 2;
inline int ProjectorConfig::embeddings_size() const {
  return embeddings_.size();
}
inline void ProjectorConfig::clear_embeddings() {
  embeddings_.Clear();
}
inline ::diplomacy::tensorflow::EmbeddingInfo* ProjectorConfig::mutable_embeddings(int index) {
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.ProjectorConfig.embeddings)
  return embeddings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::diplomacy::tensorflow::EmbeddingInfo >*
ProjectorConfig::mutable_embeddings() {
  // @@protoc_insertion_point(field_mutable_list:diplomacy.tensorflow.ProjectorConfig.embeddings)
  return &embeddings_;
}
inline const ::diplomacy::tensorflow::EmbeddingInfo& ProjectorConfig::embeddings(int index) const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.ProjectorConfig.embeddings)
  return embeddings_.Get(index);
}
inline ::diplomacy::tensorflow::EmbeddingInfo* ProjectorConfig::add_embeddings() {
  // @@protoc_insertion_point(field_add:diplomacy.tensorflow.ProjectorConfig.embeddings)
  return embeddings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::diplomacy::tensorflow::EmbeddingInfo >&
ProjectorConfig::embeddings() const {
  // @@protoc_insertion_point(field_list:diplomacy.tensorflow.ProjectorConfig.embeddings)
  return embeddings_;
}

// string model_checkpoint_dir = 3;
inline void ProjectorConfig::clear_model_checkpoint_dir() {
  model_checkpoint_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectorConfig::model_checkpoint_dir() const {
  // @@protoc_insertion_point(field_get:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
  return model_checkpoint_dir_.GetNoArena();
}
inline void ProjectorConfig::set_model_checkpoint_dir(const ::std::string& value) {
  
  model_checkpoint_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
}
#if LANG_CXX11
inline void ProjectorConfig::set_model_checkpoint_dir(::std::string&& value) {
  
  model_checkpoint_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
}
#endif
inline void ProjectorConfig::set_model_checkpoint_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_checkpoint_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
}
inline void ProjectorConfig::set_model_checkpoint_dir(const char* value, size_t size) {
  
  model_checkpoint_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
}
inline ::std::string* ProjectorConfig::mutable_model_checkpoint_dir() {
  
  // @@protoc_insertion_point(field_mutable:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
  return model_checkpoint_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectorConfig::release_model_checkpoint_dir() {
  // @@protoc_insertion_point(field_release:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
  
  return model_checkpoint_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectorConfig::set_allocated_model_checkpoint_dir(::std::string* model_checkpoint_dir) {
  if (model_checkpoint_dir != NULL) {
    
  } else {
    
  }
  model_checkpoint_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_checkpoint_dir);
  // @@protoc_insertion_point(field_set_allocated:diplomacy.tensorflow.ProjectorConfig.model_checkpoint_dir)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow
}  // namespace diplomacy

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_diplomacy_5ftensorflow_2fcontrib_2ftensorboard_2fplugins_2fprojector_2fprojector_5fconfig_2eproto
